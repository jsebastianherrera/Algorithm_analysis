\documentclass[]{article}
\usepackage[spanish]{babel}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathrsfs}
\graphicspath{ {graphics/} }
% Some definitions
\floatname{algorithm}{Algoritmo}

% Author info
\title{Escritura del problema del ordenamiento de datos}
\author{Juan Sebastián Herrera Guaitero$^1$}
\date{
	$^1$Departamento de Ingeniería de Sistemas, Pontificia Universidad Javeriana\\Bogotá,  Colombia \\
	\texttt{jsebastianherrera@javeriana.edu.co}\\~\\
	\today
}

\begin{document}
\maketitle

\begin{abstract}
    En este documento se presenta la formalización del problema de ordenamiento de datos, junto con la descripción de tres algoritmos que lo solucionan. Además, se presenta un análisis experimental de la complejidad de esos tres algoritmos.
    \textbf{Palabras clave:} ordenamiento, algoritmo, formalización, experimentación, complejidad.
\end{abstract}

\tableofcontents
\newpage
\section{Introducción} \label{intro}
Los algoritmos de ordenamiento de datos son muy útiles en una cantidad considerable de algoritmos que requieren orden en los datos que serán procesados. En este documento se presentan tres de ellos, con el objetivo de mostrar: la formalización del problema (sección \ref{formalizacion}), la escritura formal de tres algoritmos (sección \ref{algoritmos}) y un análisis experimental de la complejidad de cada uno de ellos (sección \ref{experimentos}).

\section{Formalización del problema} \label{formalizacion}
Cuando se piensa en el {\it ordenamiento de números} la solución inmediata puede ser muy simplista: inocentemente, se piensa en ordenar números. Sin embargo, con un poco más de reflexión, hay tres preguntas que pueden surgir:
\begin{enumerate}
    \item ¿Cuáles números?
    \item ¿Cómo se guardan esos números en memoria?
    \item ¿Solo se pueden ordenar números?
\end{enumerate}

Recordemos que los números pueden ser naturales ($\mathbb{N}$), enteros ($\mathbb{Z}$), racionales o quebrados ($\mathbb{Q}$), irracionales ($\mathbb{I}$) y complejos ($\mathbb{C}$). En todos esos conjuntos, se puede definir la relación de {\it orden parcial} $a<b$.

Esto lleva a pensar: si se puede definir la relación de orden parcial $a<b$ en cualquier conjunto $\mathbb{T}$, entonces se puede resolver el problema del ordenamiento con elementos de dicho conjunto.

\subsection{Definición del problema del ``ordenamiento de datos''} \label{problema}
Así, el problema del ordenamiento se define a partir de:
\begin{enumerate}
    \item una secuencia $S$ de elementos $a\in \mathbb{T}$ y
    \item una relación de orden parcial $a<b~\forall a,b\in \mathbb{T}$
\end{enumerate}
producir una nueva secuencia $S'$ cuyos elementos contiguos cumplan con la relación $a<b$.
\begin{itemize}
    \item Entradas:
          \begin{itemize}
              \item $S = \left< a_i \in \mathbb{T} \right> ~ | ~ 1\le i \le n$.
              \item $a<b \in \mathbb{T} \times \mathbb{T}$, una relación de orden parcial.
          \end{itemize}
    \item Salidas:
          \begin{itemize}
              \item $S' = \left< e_i \in S m\right> ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)$.
          \end{itemize}
\end{itemize}

\section{Algoritmos de solución} \label{algoritmos}
\subsection{Burbuja ``inocente''} \label{algoritmos:inocente}
La idea de este algoritmo es: comparar todos las parejas de elementos adyacentes e intercambiarlos si no cumplen con la relación de orden parcial $<$.

\begin{algorithm}[!htb]
    \caption{Ordenamiento por burbuja ``inocente''.}
    \begin{algorithmic}[1]
        \Require $S=\left< s_i \in \mathbb{T} \right> \land a<b \in \mathbb{T} \times \mathbb{T}$
        \Ensure $S$ será cambiado por $S' = \left< e_i \in S  ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)\right>$
        \Procedure{NaiveBubbleSort}{$S$}
        \For{$i \leftarrow 1~\mathbf{to}~|S|$}
        \For{$j \leftarrow 1~\mathbf{to}~|S|-1$}
        \If{$s_{j+1}<s_j$}
        \State \Call{Swap}{$s_j,s_{j+1}$}
        \EndIf
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Análisis de complejidad} \label{algoritmos:inocente:complejidad}

Por inspección de código: hay dos ciclos {\it para-todo} anidados que, en el peor de los casos, recorren todo la secuencia de datos; entonces, este algoritmo es $O(|S|^2)$.

\subsubsection{Invariante} \label{algoritmos:inocente:invariante}

Después de cada iteración controlada por el contador $i$, los $i$ elementos más grandes quedan al final de la secuencia.

\begin{enumerate}
    \item Inicio: $i=0$, la secuencia vacía está ordenada.
    \item Iteración: $1 \le i<|S|$, si se supone que los $i-1$ elementos más grandes ya están en su posición, entonces la nueva iteración llevará los $i$-ésimo elemento a su posición adecuada.
    \item Terminación: $i=|S|$, los $|S|$ elementos más grandes están en su posición, entonces la secuencia está ordenada.
\end{enumerate}

\subsection{Burbuja ``mejorado''} \label{algoritmos:mejorado}

La idea de este algoritmo es: comparar todos las parejas de elementos adyacentes e intercambiarlos si no cumplen con la relación de orden parcial $<$, con la diferencia que las comparaciones se detienen en el momento que se alcanzan los elementos más grandes que ya están en su posición final.

\begin{algorithm}[!htb]
    \caption{Ordenamiento por burbuja ``mejorado''.}
    \begin{algorithmic}[1]
        \Require $S=\left< S_i \in \mathbb{T} \right> \land a<b \in \mathbb{T} \times \mathbb{T}$
        \Ensure $S$ será cambiado por $S' = \left< e_i \in S  ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)\right>$
        \Procedure{ImprovedBubbleSort}{$S$}
        \For{$i \leftarrow 1~\mathbf{to}~|S|$}
        \For{$j \leftarrow 1~\mathbf{to}~|S|-i$} \Comment{Mejora: parar cuando se encuentren los elementos más grandes.}
        \If{$s_{j+1}<s_j$}
        \State \Call{Swap}{$s_j,s_{j+1}$}
        \EndIf
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Análisis de complejidad} \label{algoritmos:mejorado:complejidad}

Por inspección de código: hay dos ciclos {\it para-todo} anidados que, en el peor de los casos, recorren todo la secuencia de datos; entonces, este algoritmo es $O(|S|^2)$.

\subsubsection{Invariante} \label{algoritmos:mejorado:invariante}

Después de cada iteración controlada por el contador $i$, los $i$ elementos más grandes quedan al final de la secuencia.

\begin{enumerate}
    \item Inicio: $i=0$, la secuencia vacía está ordenada.
    \item Iteración: $1 \le i<|S|$, si se supone que los $i-1$ elementos más grandes ya están en su posición, entonces la nueva iteración llevará los $i$-ésimo elemento a su posición adecuada.
    \item Terminación: $i=|S|$, los $|S|$ elementos más grandes están en su posición, entonces la secuencia está ordenada.
\end{enumerate}

\subsection{Inserción} \label{algoritmos:insercion}

La idea de este algoritmo es: en cada iteración, buscar la posición donde el elemento que se está iterando quede en el orden de secuencia adecuado.

\begin{algorithm}[!htb]
    \caption{Ordenamiento por inserción.}
    \begin{algorithmic}[1]
        \Require $S=\left< S_i \in \mathbb{T} \right> \land a<b \in \mathbb{T} \times \mathbb{T}$
        \Ensure $S$ será cambiado por $S' = \left< e_i \in S m\right> ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)$
        \Procedure{InsertionSort}{$S$}
        \For{$j \leftarrow 2~\mathbf{to}~|S|$}
        \State $k \leftarrow s_j$
        \State $i \leftarrow j - 1$
        \While{$0<i \land k < s_i$}
        \State $s_{i+1} \leftarrow s_i$
        \State $i \leftarrow i - 1$
        \EndWhile
        \State $s_{i+1} \leftarrow k$
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Análisis de complejidad} \label{algoritmos:insercion:complejidad}

Por inspección de código: hay dos ciclos (un {\it mientras-que} anidado dentro de un ciclo {\it para-todo}) anidados que, en el peor de los casos, recorren todo la secuencia de datos; entonces, este algoritmo es $O(|S|^2)$.

El ciclo interior, por el hecho de ser {\it mientras-que}, puede que en algunas configuraciones no se ejecute (i.e. cuando la secuencia ya esté ordenada); entonces, este algoritmo tiene una cota inferior $\Omega(|S|)$, dónde solo el {\it para-todo} recorre la secuencia.

\subsubsection{Invariante} \label{algoritmos:insercion:invariante}

Después de cada iteración $j$, los primeros $j$ siguen la relación de orden parcial $a<b$.

\begin{enumerate}
    \item Inicio: $j \le 1$, la secuencia vacía o unitaria está ordenada.
    \item Iteración: $2 \le j < |S|$, si se supone que los $j-1$ elementos ya están ordenados, entonces la nueva iteración llevará un nuevo elemento y los $j$ primeros elementos estarán ordenados.
    \item Terminación: $j=|S|$, los $|S|$ primeros elementos están ordenados, entonces la secuencia está ordenada.
\end{enumerate}
\newpage
\subsection{Merge Sort} \label{algoritmos:mergesort}
Se basa en la estrategia de dividir y conquistar. La ordenación por fusión corta continuamente una lista en múltiples sublistas hasta que cada una de ellas tiene un solo elemento, y luego combina esas sublistas en una lista ordenada.
\begin{algorithm}[h]
    \caption{Merge Sort}
    \begin{algorithmic}[1]
        \Require $S=\left< S_i \in \mathbb{T} \right> \land a<b \in \mathbb{T} \times \mathbb{T}$
        \Ensure $S$ será cambiado por $S' = \left< e_i \in S m\right> ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)$
        \Procedure{mergeSort}{$S,l,m,r$}
        \State $len1,len2 \leftarrow m-l+1,r-m$
        \State $left,right \gets [],[]$
        \For{$i \gets 1 ~\mathbf{to} ~len1$}
        \State $left.append(S_{l+i})$
        \EndFor
        \For{$i \gets 1 ~\mathbf{to} ~len2$}
        \State $right.append(S_{m+1+i})$
        \EndFor
        \State $i,j,k \gets 0,0,1$
        \While{$i<len1 \land j < len2$}
        \If{$left_i \leqslant right_j$}
        \State $S_k \gets left_i$
        \State $i+ \gets 1$
        \Else
        \State $S_k \gets right_j$
        \State $j+ \gets 1$
        \EndIf
        \State $k+ \gets 1$
        \EndWhile
        \While{$i<len1$}
        \State $S_k \gets left_i$
        \State $k+ \gets 1$
        \State $i+ \gets 1$
        \EndWhile
        \While{$i<len2$}
        \State $S_k \gets right_j$
        \State $k+ \gets 1$
        \State $j+ \gets 1$
        \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
\subsubsection{Análisis de complejidad} \label{algoritmos:mergesort:complejidad}
Para el algoritmo de MergeSort se cuenta con una complejidad en el peor de los casos $O(nlogn)$, cuando se requieren n comparaciones. En este caso la complejidad temporal en el peor de los casos es la misma para el caso medio $\Theta$. Por último, el mejor caso se produce cuando la secuencia ya está ordenada y no se requieren intercambios, contamos con una complejidad $\Omega(n)$.
% \subsubsection{Invariante} \label{algoritmos:mergesort:invariante}
% \begin{enumerate}
%     \item Inicio: Antes de la primera iteración del bucle, tenemos k = l, por lo que la submatriz S[l ... k - 1] está vacía. esta submatriz vacía contiene los k - l = 0 elementos más pequeños de L y R, y como i = j = 1, tanto L[i] como R[j] son los elementos más pequeños de sus matrices que no se han copiado en A.
%     \item Iteración: Para ver que cada iteración mantiene la invariante del bucle, supongamos primero que l[i] <= R[j]. Entonces L[i] es el elemento más pequeño que aún no se ha copiado en S. Como A[l ... k - 1] contiene los k - l elementos más pequeños, después de L[i] en S[k], la submatriz S[l ... k] contendrá los k - p + 1 elementos más pequeños.
%     \item Terminación:  Al terminar, k = r + 1. Por la invariante del bucle, la submatriz S[l ... k - 1], que es S[l ... r], contiene los k - l = r - l + 1 elementos más pequeños de L[1 ... n1 + 1] y R[1 ... n2 + 1], ordenados.
% \end{enumerate}
\subsection{TimSort} \label{algoritmos:timsort}
La idea de este algorítmo es: dividir la secuencia en bloques conocidos como ``Run'', ordenarlos utilizando ordenamiento por inserción y luego fusionarlos utilizando ordenamiento Merge.
\begin{algorithm}[h]
    \caption{Ordenamiento TimSort.}
    \begin{algorithmic}[1]
        \Require $S=\left< S_i \in \mathbb{T} \right> \land a<b \in \mathbb{T} \times \mathbb{T}$
        \Ensure $S$ será cambiado por $S' = \left< e_i \in S m\right> ~ | ~ e_i < e_{i+1} \forall i \in \left[1,n\right)$
        \Function{calcMinRun}{$n$}
        \State $r \leftarrow 0$
        \While{$n \geq MINIMUM$}
        \State $r | \leftarrow n \& 1$
        \State $n \gg \leftarrow 1$
        \EndWhile
        \State \Return $n+r$
        \EndFunction
        \Statex
        \Procedure{TimSort}{$S$}
        \State $n  \leftarrow ~|S| $
        \State $minRun \leftarrow \Call{calcMinRun}{n}$
        \For{$start \leftarrow 1~\mathbf{to}~|S|$}
        \State $end \leftarrow \Call{min}{start+minRun-1,n-1}$
        \State $\Call{insertionSort}{S,start,end}$
        \EndFor
        \State $size \leftarrow minRun$
        \While {$size < n$}
        \For{$left \leftarrow 1 ~\mathbf{to}~n$}
        \State $mid \leftarrow \Call{min}{n-1,left+size-1}$
        \State $right \leftarrow \Call{min}{(left+2*size-1),(n-1)}$
        \If{$mid < right$}
        \State \Call{mergesort}{S,left,mid,right}
        \EndIf
        \EndFor
        \State $size \leftarrow 2*size$
        \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
\subsubsection{Análisis de complejidad} \label{algoritmos:timsort:complejidad}
Para el algoritmo de TimSort se cuenta con una complejidad en el peor de los casos $O(nlogn)$, cuando se requieren n comparaciones. En este caso la complejidad temporal en el peor de los casos es la misma para el caso medio $\Theta$. Por último, el mejor caso se produce cuando la secuencia ya está ordenada y no se requieren intercambios y para este caso contamos con una complejidad $\Omega(n)$.
\subsubsection{Invariante} \label{algoritmos:timsort:invariante}
\begin{enumerate}
    \item Inicio: $len >= 16$, para cada merge
    \item Iteración: Añadir la longitud de la nueva ejecución a la secuencia runLen mientras se cumpla $runLen[n-2] > runLen[n-1] + runLen[n]$  y $ runLen[n-1] > runLen[n]$
    \item Terminación: $n \leqslant size$ , al fusionar todas las ejecuciones dan como resultado una secuencia ordenada.
\end{enumerate}

\end{document}
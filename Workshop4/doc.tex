\documentclass[letter]{article}
\usepackage[spanish]{babel}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathrsfs}


% Some definitions
\floatname{algorithm}{Algoritmo}

% Author info
\title {Secuencia más larga de vecinos que están ordenados}
\author{ Jorge Luis Esposito Albornoz$^1$  Juan Sebastián Herrera Guaitero$^1$}
\date{
	$^1$Departamento de Ingeniería de Sistemas, Pontificia Universidad Javeriana\\Bogotá,  Colombia \\
	\texttt{\{jesposito,jsebastianherrera\}@javeriana.edu.co}\\~\\
	\today
}

\begin{document}
\maketitle

\begin{abstract}
	En este documento se presenta la formalización del problema de encontrar la secuencia más larga de vecinos que están ordenados.
	\textbf{Palabras clave:} matriz, adyacentes.
\end{abstract}

\tableofcontents

\newpage
\section{Formalización problema}
El problema de encontrar la secuencia mas larga de vecinos que estan ordenados, es un problema muy utilizado en el mundo empresarial para realizar entrevistas de conocimiento
a los candidatos. Su dificultad particular radica en la soluc\'ion del problema, los primeros acercamientos a la soluc\'ion suelen ser a trav\'es
de la recursi\'on ingenua, sin embargo, utilizar programaci\'on din\'amica es una buena opci\'on.

\subsection{Definición del problema}
Dada una matriz cuadrada natural de tamaño $NxN$, que contiene los números únicos en el rango $[1,NxN]$, pero que no están forzosamente en orden, encontrar la secuencia más larga de vecinos que están ordenados y los elementos adyacentes en la matriz que tienen una diferencia de $+1$.
\break
\break
El problema de la secuencia mas larga de vecinos ordenados se define apartir de:
\begin{enumerate}
	\item Una matriz $M$ de elementos $a\in\mathbb{Z}$.
\end{enumerate}
Generar una secuencia $S$ cuyos elementos cumplan con una relac\'ion $a<b$.
\begin{itemize}
	\item \textbf{Entradas:}
	      \begin{itemize}
          \item $M^{nxn} ~ | ~ \forall M_{ij} \in \mathbb{Z} \right>\right>$
	      \end{itemize}
	\item \textbf{Salidas:}
	      \begin{itemize}
		      \item $S = \left<s_i \in M\right> ~ | ~ \forall i \in M ~ s_i \le s_{i+1}  $
	      \end{itemize}
\end{itemize}
\section{Algoritmo de soluci\'on}
\subsection{Idea soluci\'on}
\begin{figure}[H]
	\centerline{\includegraphics[scale=0.30]{sample.jpg}}
	\caption{Matriz inicial}
	\label{fig}
\end{figure}
Se planteo la siguiente ecuaci\'on como posible soluci\'on del problema: \\
\[ M_{ij} =
	\begin{cases}
		\quad 0 & \text{if } |M| = 0 \\
		\quad \[ max=
			\begin{cases}
				M_{i-1j} & \quad \text{if } ~ i  >  1 ~ \land ~ M_{ij}+1 = M_{i-1j}   \\
				M_{i+1j} & \quad \text{if } ~ i  <  |M| ~ \land ~ M_{ij}+1 = M_{i+1j} \\
				M_{ij-1} & \quad \text{if } ~ j  >  1 ~ \land ~ M_{ij}+1 = M_{ij-1}   \\
				M_{ij+1} & \quad \text{if } ~ j  <  |M| ~ \land ~ M_{ij}+1 = M_{ij+1} \\
			\end{cases} 
		\] 
    
    
	\end{cases}
\]
Teniendo en cuenta que para cada posici\'on $ij$ dentro de la matriz pueden existir valores
adyacentes se busca obtener el valor m\'aximo.

\subsection{Escritura del algor\'itmo}
\begin{algorithm}[!htb]
	\caption{Max num}
	\begin{algorithmic}[1]
		\Function{$max$}{$a,b$}
		\If{$a > b$}
		\State \Return $a$
		\Else
		\State \Return $b$
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[!htb]
  \caption{aux}
	\begin{algorithmic}[1]
		\Procedure{$max$}{$T,M,B,i,j$}
		\State $q \gets 0$
    \If{$|T| = 0$}
    \State \Return $0$
    \If{$M_{ij} \neq 0$}
    \State \Return $M_{ij}$
		\Else
    \If{$i > 0 ~ \land ~ T_{ij}+1 = T_{i-1j}$}
    \State $q \gets \Call{max}{q,AUX(T,M,B,i-1,j)}$
    \If{$ q = M_{i-1j}$}
    \State $B_{ij} \gets pair(i-1,j)$ \Comment Pair pareja de elementos 
    \EndIf
    \EndIf
    \If{$i < |T| ~ \land ~ T_{ij}+1 = T_{i+1j}$}
    \State $q \gets \Call{max}{q,AUX(T,M,B,i+1,j)}$
    \If{$ q = M_{i-1j}$}
    \State $B_{ij} \gets pair(i+1,j)$ \Comment Pair pareja de elementos
    \EndIf
    \EndIf
    \If{$j > 0 ~ \land ~ T_{ij}+1 = T_{ij-1}$}
    \State $q \gets \Call{max}{q,AUX(T,M,B,i,j-1)}$
    \If{$ q = M_{ij-1}$}
    \State $B_{ij} \gets pair(i,j-1)$ \Comment Pair pareja de elementos 
    \EndIf
    \EndIf
    \If{$j < |T| ~ \land ~ T_{ij}+1 = T_{ij+1}$}
    \State $q \gets \Call{max}{q,AUX(T,M,B,i,j+1)}$
    \If{$ q = M_{ij+1}$}
    \State $B_{ij} \gets pair(i,j+1)$ \Comment Pair pareja de elementos
    \EndIf
    \EndIf
    \State $M_{ij} \gets q + 1 $
		\EndIf
    \State \Return $M_{ij}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\caption{LSNBacktracking}
	\begin{algorithmic}[1]
		\Procedure{$bactraking$}{$T$}
    \State \textbf{let }$M$ \textbf{ be a matrix filled with } $0$
    \State \textbf{let }$B$ \textbf{ be a matrix filled with pairs of integers}
    \State \textbf{let }$rt$ \textbf{ be an array}
    \State \textbf{let }$current$ \textbf{ be a pair of integers}
    \State $q \gets 0$
    \For{ $i \gets 1 ~ \textbf{to} ~ |T|$ }
    \For{ $j \gets 1 ~ \textbf{to} ~ |T|$ }
    \State $q \gets \Call{max}{q,AUX(T,M,B,i,j)}$
    \If{$q = M_{ij}$}
    \State $\textbf{let }current \textbf{ be a pair that stored i and j}$
    \EndIf
    \EndFor
    \EndFor
    \While{$B_{current_{1}current_{2}} ~ \neq ~ current $}
    \State \textbf{let } $rt$ \textbf{ add  } $T_{current_1current_2}$
    \State $current \gets B_{current_1current_2}$
    \EndWhile
    \State \textbf{let } $rt$ \textbf{ add  } $T_{current_1current_2}$
    \State \Return rt
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsection{An\'alisis de complejidad}
\subsection{Invariante}
\section{An\'alisis experimental}
\subsection{Protocolo}
\subsection{Procedimiento}
\subsection{Resultado}
\subsection{An\'alisis}
\section{Conclusiones}

\end{document}

